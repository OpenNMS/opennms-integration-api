var _imports_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASgAAAA3CAYAAAC/8NfjAAAACXBIWXMAACxLAAAsSwGlPZapAAAGxmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDYgNzkuMTY0NzUzLCAyMDIxLzAyLzE1LTExOjUyOjEzICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjIuMyAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjEtMDItMjRUMDg6NDg6NDgtMDU6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIxLTA0LTI4VDExOjM4OjA2LTA0OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIxLTA0LTI4VDExOjM4OjA2LTA0OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjQzYWViY2Y0LTNiZjMtNDZlMS1iZjQwLTM4NTUyNDJlYzFlMiIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjRhMTRiMDdjLTY2ZGItYTk0OS1iOWI0LTZhYzEzNjBjMWY1NSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOmFhNDBmNTBiLWQ5Y2YtNDdhYS05YzNlLTE3ZmFmMmUxM2Q2OSI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YWE0MGY1MGItZDljZi00N2FhLTljM2UtMTdmYWYyZTEzZDY5IiBzdEV2dDp3aGVuPSIyMDIxLTAyLTI0VDA4OjQ4OjQ4LTA1OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjIuMyAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6OTE0ZTE1MWEtNGY1Ni00ZGQ4LWEyYzQtNWIxMDM3Y2FhN2IzIiBzdEV2dDp3aGVuPSIyMDIxLTA0LTI4VDExOjM1OjIyLTA0OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjIuMyAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NDNhZWJjZjQtM2JmMy00NmUxLWJmNDAtMzg1NTI0MmVjMWUyIiBzdEV2dDp3aGVuPSIyMDIxLTA0LTI4VDExOjM4OjA2LTA0OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjIuMyAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7r1nVO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";
var App_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => "#app[data-v-a62ce854]{font-family:Avenir,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-align:center;color:#2c3e50;margin-top:60px}\n")();
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$1 = {};
const _createElementVNode$1 = window["Vue"].createElementVNode;
const _resolveComponent = window["Vue"].resolveComponent;
const _createVNode = window["Vue"].createVNode;
const _Fragment$1 = window["Vue"].Fragment;
const _openBlock$1 = window["Vue"].openBlock;
const _createElementBlock$1 = window["Vue"].createElementBlock;
const _pushScopeId$1 = window["Vue"].pushScopeId;
const _popScopeId$1 = window["Vue"].popScopeId;
const _withScopeId$1 = (n) => (_pushScopeId$1("data-v-a62ce854"), n = n(), _popScopeId$1(), n);
const _hoisted_1$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ _createElementVNode$1("img", {
  alt: "Vue logo",
  src: _imports_0
}, null, -1));
function _sfc_render(_ctx, _cache) {
  const _component_router_view = _resolveComponent("router-view");
  return _openBlock$1(), _createElementBlock$1(_Fragment$1, null, [
    _hoisted_1$1,
    _createVNode(_component_router_view)
  ], 64);
}
var App = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-a62ce854"]]);
/*!
  * vue-router v4.0.16
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
window["Vue"].getCurrentInstance;
const inject = window["Vue"].inject;
window["Vue"].onUnmounted;
window["Vue"].onDeactivated;
window["Vue"].onActivated;
const computed = window["Vue"].computed;
const unref = window["Vue"].unref;
window["Vue"].watchEffect;
const defineComponent = window["Vue"].defineComponent;
const reactive = window["Vue"].reactive;
const h = window["Vue"].h;
const provide = window["Vue"].provide;
const ref$1 = window["Vue"].ref;
const watch = window["Vue"].watch;
const shallowRef = window["Vue"].shallowRef;
const nextTick = window["Vue"].nextTick;
const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
const PolySymbol = (name) => hasSymbol ? Symbol(name) : "_vr_" + name;
const matchedRouteKey = /* @__PURE__ */ PolySymbol("rvlm");
const viewDepthKey = /* @__PURE__ */ PolySymbol("rvd");
const routerKey = /* @__PURE__ */ PolySymbol("r");
const routeLocationKey = /* @__PURE__ */ PolySymbol("rl");
const routerViewLocationKey = /* @__PURE__ */ PolySymbol("rvl");
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === "Module";
}
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop = () => {
};
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const searchPos = location2.indexOf("?");
  const hashPos = location2.indexOf("#", searchPos > -1 ? searchPos : 0);
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return Array.isArray(a) ? isEquivalentArray(a, b) : Array.isArray(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return Array.isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (position === 1 || segment === ".")
      continue;
    if (segment === "..")
      position--;
    else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1)
        listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      position: history2.length - 1,
      replaced: true,
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to, data) {
    const state = assign({}, history2.state, buildState(historyState.value.back, to, historyState.value.forward, true), data, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data) {
    const currentState = assign({}, historyState.value, history2.state, {
      forward: to,
      scroll: computeScrollPosition()
    });
    changeLocation(currentState.current, currentState, true);
    const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign({
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = /* @__PURE__ */ PolySymbol("nf");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [90];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys.push({
          name: value,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse(path) {
    const match = path.match(re);
    const params = {};
    if (!match)
      return null;
    for (let i = 1; i < match.length; i++) {
      const value = match[i] || "";
      const key = keys[i - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (Array.isArray(param) && !repeatable)
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          const text = Array.isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2 && segments.length > 1) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path;
  }
  return {
    re,
    score,
    keys,
    parse,
    stringify
  };
}
function compareScoreArray(a, b) {
  let i = 0;
  while (i < a.length && i < b.length) {
    const diff = b[i] - a[i];
    if (diff)
      return diff;
    i++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser, {
    record,
    parent,
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes2, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if ("children" in mainNormalizedRecord) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i = 0;
    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))
      i++;
    matchers.splice(i, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign(paramsFromLocation(currentLocation.params, matcher.keys.filter((k) => !k.optional).map((k) => k.name)), location2.params);
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes2.forEach((route) => addRoute(route));
  return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
  const newParams = {};
  for (const key of keys) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || {} : { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "boolean" ? props : props[name];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!Array.isArray(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = Array.isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = Array.isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
function useCallbacks() {
  let handlers = [];
  function add(handler) {
    handlers.push(handler);
    return () => {
      const i = handlers.indexOf(handler);
      if (i > -1)
        handlers.splice(i, 1);
    };
  }
  function reset() {
    handlers = [];
  }
  return {
    add,
    list: () => handlers,
    reset
  };
}
function guardToPromiseFn(guard, to, from, record, name) {
  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve, reject) => {
    const next = (valid) => {
      if (valid === false)
        reject(createRouterError(4, {
          from,
          to
        }));
      else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function")
          enterCallbackArray.push(valid);
        resolve();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to, from, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router[unref(props.replace) ? "replace" : "push"](unref(props.to)).catch(noop);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const depth = inject(viewDepthKey, 0);
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);
    provide(viewDepthKey, depth + 1);
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref$1();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[props.name];
      const currentName = props.name;
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[props.name];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return normalizeSlot(slots.default, { Component: component, route }) || component;
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode);
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      hash,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      return assign({
        query: to.query,
        hash: to.hash,
        params: to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
        state: data,
        force,
        replace: replace2
      }), redirectedFrom || targetLocation);
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(from, from, true, false);
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(failure2, 2)) {
          return pushWithRedirect(assign(locationAsObject(failure2.to), {
            state: data,
            force,
            replace: replace2
          }), redirectedFrom || toLocation);
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to.matched) {
        if (record.beforeEnter && !from.matched.includes(record)) {
          if (Array.isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    for (const guard of afterGuards.list())
      guard(to, from, failure);
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      const toLocation = resolve(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(error, 4 | 8)) {
          return error;
        }
        if (isNavigationFailure(error, 2)) {
          pushWithRedirect(error.to, toLocation).then((failure) => {
            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta)
          routerHistory.go(-info.delta, false);
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(toLocation, from, false);
        if (failure) {
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve2, reject) => {
      readyHandlers.add([resolve2, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve2, reject]) => err ? reject(err) : resolve2());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app) {
      const router2 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router2;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        reactiveRoute[key] = computed(() => currentRoute.value[key]);
      }
      app.provide(routerKey, router2);
      app.provide(routeLocationKey, reactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function() {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  return router;
}
function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
var HelloWorld_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => "a[data-v-5ac905a0]{color:#42b983}code[data-v-5ac905a0]{background-color:#eee;padding:2px 4px;border-radius:4px;color:#304455}table[data-v-5ac905a0],th[data-v-5ac905a0],td[data-v-5ac905a0]{border:2px solid black;border-collapse:collapse}th[data-v-5ac905a0]{background-color:#228b22}\n")();
const _defineComponent = window["Vue"].defineComponent;
const _createElementVNode = window["Vue"].createElementVNode;
const _createTextVNode = window["Vue"].createTextVNode;
const _toDisplayString = window["Vue"].toDisplayString;
const _Fragment = window["Vue"].Fragment;
const _openBlock = window["Vue"].openBlock;
const _createElementBlock = window["Vue"].createElementBlock;
const _pushScopeId = window["Vue"].pushScopeId;
const _popScopeId = window["Vue"].popScopeId;
const _withScopeId = (n) => (_pushScopeId("data-v-5ac905a0"), n = n(), _popScopeId(), n);
const _hoisted_1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ _createElementVNode("h1", null, "This is an example UI Extension component plugin installed at runtime as a Karaf feature", -1));
const _hoisted_2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ _createElementVNode("p", null, [
  /* @__PURE__ */ _createTextVNode(" For more information: "),
  /* @__PURE__ */ _createElementVNode("a", {
    href: "https://github.com/OpenNMS/opennms-integration-api",
    target: "_blank"
  }, "OpenNMS Integration API")
], -1));
const _hoisted_3 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ _createElementVNode("table", { style: { "width": "60%" } }, [
  /* @__PURE__ */ _createElementVNode("tr", null, [
    /* @__PURE__ */ _createElementVNode("th", { style: { "width": "20%" } }, "Product"),
    /* @__PURE__ */ _createElementVNode("th", { style: { "width": "40%" } }, "Description")
  ]),
  /* @__PURE__ */ _createElementVNode("tr", null, [
    /* @__PURE__ */ _createElementVNode("td", null, "Horizon"),
    /* @__PURE__ */ _createElementVNode("td", null, "Our free community-driven project includes the latest technology and features delivered through a rapid release cycle.")
  ]),
  /* @__PURE__ */ _createElementVNode("tr", null, [
    /* @__PURE__ */ _createElementVNode("td", null, "Meridian"),
    /* @__PURE__ */ _createElementVNode("td", null, "Meridian is a subscription-based, optimized and stable version of the OpenNMS platform.")
  ])
], -1));
const ref = window["Vue"].ref;
const _sfc_main = /* @__PURE__ */ _defineComponent({
  __name: "HelloWorld",
  setup(__props) {
    const count = ref(0);
    return (_ctx, _cache) => {
      return _openBlock(), _createElementBlock(_Fragment, null, [
        _hoisted_1,
        _hoisted_2,
        _createElementVNode("button", {
          type: "button",
          onClick: _cache[0] || (_cache[0] = ($event) => count.value++)
        }, "count is: " + _toDisplayString(count.value), 1),
        _hoisted_3
      ], 64);
    };
  }
});
var HelloWorld = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-5ac905a0"]]);
const routes = [
  {
    path: "/",
    name: "hello",
    component: HelloWorld
  }
];
const VRouter = window.VRouter;
if (VRouter) {
  for (const route of routes) {
    const { path, name, component } = route;
    VRouter.addRoute("Plugin", { path: path.slice(1), name, component });
  }
}
createRouter({
  history: createWebHistory(),
  routes
});
window["Vue"].createApp;
window["Pinia"].createPinia;
window["uiextension"] = App;
